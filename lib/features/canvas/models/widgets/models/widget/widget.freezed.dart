// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'widget.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$WidgetTearOff {
  const _$WidgetTearOff();

  Paragraph paragraph({String? data, WidgetType type = WidgetType.component}) {
    return Paragraph(
      data: data,
      type: type,
    );
  }

  Heading heading({String? data, WidgetType type = WidgetType.component}) {
    return Heading(
      data: data,
      type: type,
    );
  }

  Blockquote blockquote(
      {String? data, WidgetType type = WidgetType.component}) {
    return Blockquote(
      data: data,
      type: type,
    );
  }

  Bold bold({String? data, WidgetType type = WidgetType.component}) {
    return Bold(
      data: data,
      type: type,
    );
  }

  Italicize italicize({String? data, WidgetType type = WidgetType.component}) {
    return Italicize(
      data: data,
      type: type,
    );
  }

  BulletedList bulletedList(
      {String? data, WidgetType type = WidgetType.component}) {
    return BulletedList(
      data: data,
      type: type,
    );
  }

  Table table({String? data, WidgetType type = WidgetType.component}) {
    return Table(
      data: data,
      type: type,
    );
  }

  Image image({String? data, WidgetType type = WidgetType.component}) {
    return Image(
      data: data,
      type: type,
    );
  }
}

/// @nodoc
const $Widget = _$WidgetTearOff();

/// @nodoc
mixin _$Widget {
  String? get data => throw _privateConstructorUsedError;
  WidgetType get type => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? data, WidgetType type) paragraph,
    required TResult Function(String? data, WidgetType type) heading,
    required TResult Function(String? data, WidgetType type) blockquote,
    required TResult Function(String? data, WidgetType type) bold,
    required TResult Function(String? data, WidgetType type) italicize,
    required TResult Function(String? data, WidgetType type) bulletedList,
    required TResult Function(String? data, WidgetType type) table,
    required TResult Function(String? data, WidgetType type) image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Paragraph value) paragraph,
    required TResult Function(Heading value) heading,
    required TResult Function(Blockquote value) blockquote,
    required TResult Function(Bold value) bold,
    required TResult Function(Italicize value) italicize,
    required TResult Function(BulletedList value) bulletedList,
    required TResult Function(Table value) table,
    required TResult Function(Image value) image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WidgetCopyWith<Widget> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WidgetCopyWith<$Res> {
  factory $WidgetCopyWith(Widget value, $Res Function(Widget) then) =
      _$WidgetCopyWithImpl<$Res>;
  $Res call({String? data, WidgetType type});
}

/// @nodoc
class _$WidgetCopyWithImpl<$Res> implements $WidgetCopyWith<$Res> {
  _$WidgetCopyWithImpl(this._value, this._then);

  final Widget _value;
  // ignore: unused_field
  final $Res Function(Widget) _then;

  @override
  $Res call({
    Object? data = freezed,
    Object? type = freezed,
  }) {
    return _then(_value.copyWith(
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as WidgetType,
    ));
  }
}

/// @nodoc
abstract class $ParagraphCopyWith<$Res> implements $WidgetCopyWith<$Res> {
  factory $ParagraphCopyWith(Paragraph value, $Res Function(Paragraph) then) =
      _$ParagraphCopyWithImpl<$Res>;
  @override
  $Res call({String? data, WidgetType type});
}

/// @nodoc
class _$ParagraphCopyWithImpl<$Res> extends _$WidgetCopyWithImpl<$Res>
    implements $ParagraphCopyWith<$Res> {
  _$ParagraphCopyWithImpl(Paragraph _value, $Res Function(Paragraph) _then)
      : super(_value, (v) => _then(v as Paragraph));

  @override
  Paragraph get _value => super._value as Paragraph;

  @override
  $Res call({
    Object? data = freezed,
    Object? type = freezed,
  }) {
    return _then(Paragraph(
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as WidgetType,
    ));
  }
}

/// @nodoc

class _$Paragraph extends Paragraph with DiagnosticableTreeMixin {
  const _$Paragraph({this.data, this.type = WidgetType.component}) : super._();

  @override
  final String? data;
  @JsonKey(defaultValue: WidgetType.component)
  @override
  final WidgetType type;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Widget.paragraph(data: $data, type: $type)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Widget.paragraph'))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('type', type));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Paragraph &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data, type);

  @JsonKey(ignore: true)
  @override
  $ParagraphCopyWith<Paragraph> get copyWith =>
      _$ParagraphCopyWithImpl<Paragraph>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? data, WidgetType type) paragraph,
    required TResult Function(String? data, WidgetType type) heading,
    required TResult Function(String? data, WidgetType type) blockquote,
    required TResult Function(String? data, WidgetType type) bold,
    required TResult Function(String? data, WidgetType type) italicize,
    required TResult Function(String? data, WidgetType type) bulletedList,
    required TResult Function(String? data, WidgetType type) table,
    required TResult Function(String? data, WidgetType type) image,
  }) {
    return paragraph(data, type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
  }) {
    return paragraph?.call(data, type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
    required TResult orElse(),
  }) {
    if (paragraph != null) {
      return paragraph(data, type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Paragraph value) paragraph,
    required TResult Function(Heading value) heading,
    required TResult Function(Blockquote value) blockquote,
    required TResult Function(Bold value) bold,
    required TResult Function(Italicize value) italicize,
    required TResult Function(BulletedList value) bulletedList,
    required TResult Function(Table value) table,
    required TResult Function(Image value) image,
  }) {
    return paragraph(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
  }) {
    return paragraph?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
    required TResult orElse(),
  }) {
    if (paragraph != null) {
      return paragraph(this);
    }
    return orElse();
  }
}

abstract class Paragraph extends Widget {
  const factory Paragraph({String? data, WidgetType type}) = _$Paragraph;
  const Paragraph._() : super._();

  @override
  String? get data;
  @override
  WidgetType get type;
  @override
  @JsonKey(ignore: true)
  $ParagraphCopyWith<Paragraph> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $HeadingCopyWith<$Res> implements $WidgetCopyWith<$Res> {
  factory $HeadingCopyWith(Heading value, $Res Function(Heading) then) =
      _$HeadingCopyWithImpl<$Res>;
  @override
  $Res call({String? data, WidgetType type});
}

/// @nodoc
class _$HeadingCopyWithImpl<$Res> extends _$WidgetCopyWithImpl<$Res>
    implements $HeadingCopyWith<$Res> {
  _$HeadingCopyWithImpl(Heading _value, $Res Function(Heading) _then)
      : super(_value, (v) => _then(v as Heading));

  @override
  Heading get _value => super._value as Heading;

  @override
  $Res call({
    Object? data = freezed,
    Object? type = freezed,
  }) {
    return _then(Heading(
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as WidgetType,
    ));
  }
}

/// @nodoc

class _$Heading extends Heading with DiagnosticableTreeMixin {
  const _$Heading({this.data, this.type = WidgetType.component}) : super._();

  @override
  final String? data;
  @JsonKey(defaultValue: WidgetType.component)
  @override
  final WidgetType type;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Widget.heading(data: $data, type: $type)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Widget.heading'))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('type', type));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Heading &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data, type);

  @JsonKey(ignore: true)
  @override
  $HeadingCopyWith<Heading> get copyWith =>
      _$HeadingCopyWithImpl<Heading>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? data, WidgetType type) paragraph,
    required TResult Function(String? data, WidgetType type) heading,
    required TResult Function(String? data, WidgetType type) blockquote,
    required TResult Function(String? data, WidgetType type) bold,
    required TResult Function(String? data, WidgetType type) italicize,
    required TResult Function(String? data, WidgetType type) bulletedList,
    required TResult Function(String? data, WidgetType type) table,
    required TResult Function(String? data, WidgetType type) image,
  }) {
    return heading(data, type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
  }) {
    return heading?.call(data, type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
    required TResult orElse(),
  }) {
    if (heading != null) {
      return heading(data, type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Paragraph value) paragraph,
    required TResult Function(Heading value) heading,
    required TResult Function(Blockquote value) blockquote,
    required TResult Function(Bold value) bold,
    required TResult Function(Italicize value) italicize,
    required TResult Function(BulletedList value) bulletedList,
    required TResult Function(Table value) table,
    required TResult Function(Image value) image,
  }) {
    return heading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
  }) {
    return heading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
    required TResult orElse(),
  }) {
    if (heading != null) {
      return heading(this);
    }
    return orElse();
  }
}

abstract class Heading extends Widget {
  const factory Heading({String? data, WidgetType type}) = _$Heading;
  const Heading._() : super._();

  @override
  String? get data;
  @override
  WidgetType get type;
  @override
  @JsonKey(ignore: true)
  $HeadingCopyWith<Heading> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BlockquoteCopyWith<$Res> implements $WidgetCopyWith<$Res> {
  factory $BlockquoteCopyWith(
          Blockquote value, $Res Function(Blockquote) then) =
      _$BlockquoteCopyWithImpl<$Res>;
  @override
  $Res call({String? data, WidgetType type});
}

/// @nodoc
class _$BlockquoteCopyWithImpl<$Res> extends _$WidgetCopyWithImpl<$Res>
    implements $BlockquoteCopyWith<$Res> {
  _$BlockquoteCopyWithImpl(Blockquote _value, $Res Function(Blockquote) _then)
      : super(_value, (v) => _then(v as Blockquote));

  @override
  Blockquote get _value => super._value as Blockquote;

  @override
  $Res call({
    Object? data = freezed,
    Object? type = freezed,
  }) {
    return _then(Blockquote(
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as WidgetType,
    ));
  }
}

/// @nodoc

class _$Blockquote extends Blockquote with DiagnosticableTreeMixin {
  const _$Blockquote({this.data, this.type = WidgetType.component}) : super._();

  @override
  final String? data;
  @JsonKey(defaultValue: WidgetType.component)
  @override
  final WidgetType type;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Widget.blockquote(data: $data, type: $type)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Widget.blockquote'))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('type', type));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Blockquote &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data, type);

  @JsonKey(ignore: true)
  @override
  $BlockquoteCopyWith<Blockquote> get copyWith =>
      _$BlockquoteCopyWithImpl<Blockquote>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? data, WidgetType type) paragraph,
    required TResult Function(String? data, WidgetType type) heading,
    required TResult Function(String? data, WidgetType type) blockquote,
    required TResult Function(String? data, WidgetType type) bold,
    required TResult Function(String? data, WidgetType type) italicize,
    required TResult Function(String? data, WidgetType type) bulletedList,
    required TResult Function(String? data, WidgetType type) table,
    required TResult Function(String? data, WidgetType type) image,
  }) {
    return blockquote(data, type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
  }) {
    return blockquote?.call(data, type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
    required TResult orElse(),
  }) {
    if (blockquote != null) {
      return blockquote(data, type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Paragraph value) paragraph,
    required TResult Function(Heading value) heading,
    required TResult Function(Blockquote value) blockquote,
    required TResult Function(Bold value) bold,
    required TResult Function(Italicize value) italicize,
    required TResult Function(BulletedList value) bulletedList,
    required TResult Function(Table value) table,
    required TResult Function(Image value) image,
  }) {
    return blockquote(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
  }) {
    return blockquote?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
    required TResult orElse(),
  }) {
    if (blockquote != null) {
      return blockquote(this);
    }
    return orElse();
  }
}

abstract class Blockquote extends Widget {
  const factory Blockquote({String? data, WidgetType type}) = _$Blockquote;
  const Blockquote._() : super._();

  @override
  String? get data;
  @override
  WidgetType get type;
  @override
  @JsonKey(ignore: true)
  $BlockquoteCopyWith<Blockquote> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BoldCopyWith<$Res> implements $WidgetCopyWith<$Res> {
  factory $BoldCopyWith(Bold value, $Res Function(Bold) then) =
      _$BoldCopyWithImpl<$Res>;
  @override
  $Res call({String? data, WidgetType type});
}

/// @nodoc
class _$BoldCopyWithImpl<$Res> extends _$WidgetCopyWithImpl<$Res>
    implements $BoldCopyWith<$Res> {
  _$BoldCopyWithImpl(Bold _value, $Res Function(Bold) _then)
      : super(_value, (v) => _then(v as Bold));

  @override
  Bold get _value => super._value as Bold;

  @override
  $Res call({
    Object? data = freezed,
    Object? type = freezed,
  }) {
    return _then(Bold(
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as WidgetType,
    ));
  }
}

/// @nodoc

class _$Bold extends Bold with DiagnosticableTreeMixin {
  const _$Bold({this.data, this.type = WidgetType.component}) : super._();

  @override
  final String? data;
  @JsonKey(defaultValue: WidgetType.component)
  @override
  final WidgetType type;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Widget.bold(data: $data, type: $type)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Widget.bold'))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('type', type));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Bold &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data, type);

  @JsonKey(ignore: true)
  @override
  $BoldCopyWith<Bold> get copyWith =>
      _$BoldCopyWithImpl<Bold>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? data, WidgetType type) paragraph,
    required TResult Function(String? data, WidgetType type) heading,
    required TResult Function(String? data, WidgetType type) blockquote,
    required TResult Function(String? data, WidgetType type) bold,
    required TResult Function(String? data, WidgetType type) italicize,
    required TResult Function(String? data, WidgetType type) bulletedList,
    required TResult Function(String? data, WidgetType type) table,
    required TResult Function(String? data, WidgetType type) image,
  }) {
    return bold(data, type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
  }) {
    return bold?.call(data, type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
    required TResult orElse(),
  }) {
    if (bold != null) {
      return bold(data, type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Paragraph value) paragraph,
    required TResult Function(Heading value) heading,
    required TResult Function(Blockquote value) blockquote,
    required TResult Function(Bold value) bold,
    required TResult Function(Italicize value) italicize,
    required TResult Function(BulletedList value) bulletedList,
    required TResult Function(Table value) table,
    required TResult Function(Image value) image,
  }) {
    return bold(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
  }) {
    return bold?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
    required TResult orElse(),
  }) {
    if (bold != null) {
      return bold(this);
    }
    return orElse();
  }
}

abstract class Bold extends Widget {
  const factory Bold({String? data, WidgetType type}) = _$Bold;
  const Bold._() : super._();

  @override
  String? get data;
  @override
  WidgetType get type;
  @override
  @JsonKey(ignore: true)
  $BoldCopyWith<Bold> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ItalicizeCopyWith<$Res> implements $WidgetCopyWith<$Res> {
  factory $ItalicizeCopyWith(Italicize value, $Res Function(Italicize) then) =
      _$ItalicizeCopyWithImpl<$Res>;
  @override
  $Res call({String? data, WidgetType type});
}

/// @nodoc
class _$ItalicizeCopyWithImpl<$Res> extends _$WidgetCopyWithImpl<$Res>
    implements $ItalicizeCopyWith<$Res> {
  _$ItalicizeCopyWithImpl(Italicize _value, $Res Function(Italicize) _then)
      : super(_value, (v) => _then(v as Italicize));

  @override
  Italicize get _value => super._value as Italicize;

  @override
  $Res call({
    Object? data = freezed,
    Object? type = freezed,
  }) {
    return _then(Italicize(
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as WidgetType,
    ));
  }
}

/// @nodoc

class _$Italicize extends Italicize with DiagnosticableTreeMixin {
  const _$Italicize({this.data, this.type = WidgetType.component}) : super._();

  @override
  final String? data;
  @JsonKey(defaultValue: WidgetType.component)
  @override
  final WidgetType type;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Widget.italicize(data: $data, type: $type)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Widget.italicize'))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('type', type));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Italicize &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data, type);

  @JsonKey(ignore: true)
  @override
  $ItalicizeCopyWith<Italicize> get copyWith =>
      _$ItalicizeCopyWithImpl<Italicize>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? data, WidgetType type) paragraph,
    required TResult Function(String? data, WidgetType type) heading,
    required TResult Function(String? data, WidgetType type) blockquote,
    required TResult Function(String? data, WidgetType type) bold,
    required TResult Function(String? data, WidgetType type) italicize,
    required TResult Function(String? data, WidgetType type) bulletedList,
    required TResult Function(String? data, WidgetType type) table,
    required TResult Function(String? data, WidgetType type) image,
  }) {
    return italicize(data, type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
  }) {
    return italicize?.call(data, type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
    required TResult orElse(),
  }) {
    if (italicize != null) {
      return italicize(data, type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Paragraph value) paragraph,
    required TResult Function(Heading value) heading,
    required TResult Function(Blockquote value) blockquote,
    required TResult Function(Bold value) bold,
    required TResult Function(Italicize value) italicize,
    required TResult Function(BulletedList value) bulletedList,
    required TResult Function(Table value) table,
    required TResult Function(Image value) image,
  }) {
    return italicize(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
  }) {
    return italicize?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
    required TResult orElse(),
  }) {
    if (italicize != null) {
      return italicize(this);
    }
    return orElse();
  }
}

abstract class Italicize extends Widget {
  const factory Italicize({String? data, WidgetType type}) = _$Italicize;
  const Italicize._() : super._();

  @override
  String? get data;
  @override
  WidgetType get type;
  @override
  @JsonKey(ignore: true)
  $ItalicizeCopyWith<Italicize> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BulletedListCopyWith<$Res> implements $WidgetCopyWith<$Res> {
  factory $BulletedListCopyWith(
          BulletedList value, $Res Function(BulletedList) then) =
      _$BulletedListCopyWithImpl<$Res>;
  @override
  $Res call({String? data, WidgetType type});
}

/// @nodoc
class _$BulletedListCopyWithImpl<$Res> extends _$WidgetCopyWithImpl<$Res>
    implements $BulletedListCopyWith<$Res> {
  _$BulletedListCopyWithImpl(
      BulletedList _value, $Res Function(BulletedList) _then)
      : super(_value, (v) => _then(v as BulletedList));

  @override
  BulletedList get _value => super._value as BulletedList;

  @override
  $Res call({
    Object? data = freezed,
    Object? type = freezed,
  }) {
    return _then(BulletedList(
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as WidgetType,
    ));
  }
}

/// @nodoc

class _$BulletedList extends BulletedList with DiagnosticableTreeMixin {
  const _$BulletedList({this.data, this.type = WidgetType.component})
      : super._();

  @override
  final String? data;
  @JsonKey(defaultValue: WidgetType.component)
  @override
  final WidgetType type;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Widget.bulletedList(data: $data, type: $type)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Widget.bulletedList'))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('type', type));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is BulletedList &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data, type);

  @JsonKey(ignore: true)
  @override
  $BulletedListCopyWith<BulletedList> get copyWith =>
      _$BulletedListCopyWithImpl<BulletedList>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? data, WidgetType type) paragraph,
    required TResult Function(String? data, WidgetType type) heading,
    required TResult Function(String? data, WidgetType type) blockquote,
    required TResult Function(String? data, WidgetType type) bold,
    required TResult Function(String? data, WidgetType type) italicize,
    required TResult Function(String? data, WidgetType type) bulletedList,
    required TResult Function(String? data, WidgetType type) table,
    required TResult Function(String? data, WidgetType type) image,
  }) {
    return bulletedList(data, type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
  }) {
    return bulletedList?.call(data, type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
    required TResult orElse(),
  }) {
    if (bulletedList != null) {
      return bulletedList(data, type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Paragraph value) paragraph,
    required TResult Function(Heading value) heading,
    required TResult Function(Blockquote value) blockquote,
    required TResult Function(Bold value) bold,
    required TResult Function(Italicize value) italicize,
    required TResult Function(BulletedList value) bulletedList,
    required TResult Function(Table value) table,
    required TResult Function(Image value) image,
  }) {
    return bulletedList(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
  }) {
    return bulletedList?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
    required TResult orElse(),
  }) {
    if (bulletedList != null) {
      return bulletedList(this);
    }
    return orElse();
  }
}

abstract class BulletedList extends Widget {
  const factory BulletedList({String? data, WidgetType type}) = _$BulletedList;
  const BulletedList._() : super._();

  @override
  String? get data;
  @override
  WidgetType get type;
  @override
  @JsonKey(ignore: true)
  $BulletedListCopyWith<BulletedList> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TableCopyWith<$Res> implements $WidgetCopyWith<$Res> {
  factory $TableCopyWith(Table value, $Res Function(Table) then) =
      _$TableCopyWithImpl<$Res>;
  @override
  $Res call({String? data, WidgetType type});
}

/// @nodoc
class _$TableCopyWithImpl<$Res> extends _$WidgetCopyWithImpl<$Res>
    implements $TableCopyWith<$Res> {
  _$TableCopyWithImpl(Table _value, $Res Function(Table) _then)
      : super(_value, (v) => _then(v as Table));

  @override
  Table get _value => super._value as Table;

  @override
  $Res call({
    Object? data = freezed,
    Object? type = freezed,
  }) {
    return _then(Table(
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as WidgetType,
    ));
  }
}

/// @nodoc

class _$Table extends Table with DiagnosticableTreeMixin {
  const _$Table({this.data, this.type = WidgetType.component}) : super._();

  @override
  final String? data;
  @JsonKey(defaultValue: WidgetType.component)
  @override
  final WidgetType type;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Widget.table(data: $data, type: $type)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Widget.table'))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('type', type));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Table &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data, type);

  @JsonKey(ignore: true)
  @override
  $TableCopyWith<Table> get copyWith =>
      _$TableCopyWithImpl<Table>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? data, WidgetType type) paragraph,
    required TResult Function(String? data, WidgetType type) heading,
    required TResult Function(String? data, WidgetType type) blockquote,
    required TResult Function(String? data, WidgetType type) bold,
    required TResult Function(String? data, WidgetType type) italicize,
    required TResult Function(String? data, WidgetType type) bulletedList,
    required TResult Function(String? data, WidgetType type) table,
    required TResult Function(String? data, WidgetType type) image,
  }) {
    return table(data, type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
  }) {
    return table?.call(data, type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
    required TResult orElse(),
  }) {
    if (table != null) {
      return table(data, type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Paragraph value) paragraph,
    required TResult Function(Heading value) heading,
    required TResult Function(Blockquote value) blockquote,
    required TResult Function(Bold value) bold,
    required TResult Function(Italicize value) italicize,
    required TResult Function(BulletedList value) bulletedList,
    required TResult Function(Table value) table,
    required TResult Function(Image value) image,
  }) {
    return table(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
  }) {
    return table?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
    required TResult orElse(),
  }) {
    if (table != null) {
      return table(this);
    }
    return orElse();
  }
}

abstract class Table extends Widget {
  const factory Table({String? data, WidgetType type}) = _$Table;
  const Table._() : super._();

  @override
  String? get data;
  @override
  WidgetType get type;
  @override
  @JsonKey(ignore: true)
  $TableCopyWith<Table> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImageCopyWith<$Res> implements $WidgetCopyWith<$Res> {
  factory $ImageCopyWith(Image value, $Res Function(Image) then) =
      _$ImageCopyWithImpl<$Res>;
  @override
  $Res call({String? data, WidgetType type});
}

/// @nodoc
class _$ImageCopyWithImpl<$Res> extends _$WidgetCopyWithImpl<$Res>
    implements $ImageCopyWith<$Res> {
  _$ImageCopyWithImpl(Image _value, $Res Function(Image) _then)
      : super(_value, (v) => _then(v as Image));

  @override
  Image get _value => super._value as Image;

  @override
  $Res call({
    Object? data = freezed,
    Object? type = freezed,
  }) {
    return _then(Image(
      data: data == freezed
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as String?,
      type: type == freezed
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as WidgetType,
    ));
  }
}

/// @nodoc

class _$Image extends Image with DiagnosticableTreeMixin {
  const _$Image({this.data, this.type = WidgetType.component}) : super._();

  @override
  final String? data;
  @JsonKey(defaultValue: WidgetType.component)
  @override
  final WidgetType type;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'Widget.image(data: $data, type: $type)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'Widget.image'))
      ..add(DiagnosticsProperty('data', data))
      ..add(DiagnosticsProperty('type', type));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is Image &&
            (identical(other.data, data) || other.data == data) &&
            (identical(other.type, type) || other.type == type));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data, type);

  @JsonKey(ignore: true)
  @override
  $ImageCopyWith<Image> get copyWith =>
      _$ImageCopyWithImpl<Image>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String? data, WidgetType type) paragraph,
    required TResult Function(String? data, WidgetType type) heading,
    required TResult Function(String? data, WidgetType type) blockquote,
    required TResult Function(String? data, WidgetType type) bold,
    required TResult Function(String? data, WidgetType type) italicize,
    required TResult Function(String? data, WidgetType type) bulletedList,
    required TResult Function(String? data, WidgetType type) table,
    required TResult Function(String? data, WidgetType type) image,
  }) {
    return image(data, type);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
  }) {
    return image?.call(data, type);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String? data, WidgetType type)? paragraph,
    TResult Function(String? data, WidgetType type)? heading,
    TResult Function(String? data, WidgetType type)? blockquote,
    TResult Function(String? data, WidgetType type)? bold,
    TResult Function(String? data, WidgetType type)? italicize,
    TResult Function(String? data, WidgetType type)? bulletedList,
    TResult Function(String? data, WidgetType type)? table,
    TResult Function(String? data, WidgetType type)? image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(data, type);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(Paragraph value) paragraph,
    required TResult Function(Heading value) heading,
    required TResult Function(Blockquote value) blockquote,
    required TResult Function(Bold value) bold,
    required TResult Function(Italicize value) italicize,
    required TResult Function(BulletedList value) bulletedList,
    required TResult Function(Table value) table,
    required TResult Function(Image value) image,
  }) {
    return image(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
  }) {
    return image?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(Paragraph value)? paragraph,
    TResult Function(Heading value)? heading,
    TResult Function(Blockquote value)? blockquote,
    TResult Function(Bold value)? bold,
    TResult Function(Italicize value)? italicize,
    TResult Function(BulletedList value)? bulletedList,
    TResult Function(Table value)? table,
    TResult Function(Image value)? image,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(this);
    }
    return orElse();
  }
}

abstract class Image extends Widget {
  const factory Image({String? data, WidgetType type}) = _$Image;
  const Image._() : super._();

  @override
  String? get data;
  @override
  WidgetType get type;
  @override
  @JsonKey(ignore: true)
  $ImageCopyWith<Image> get copyWith => throw _privateConstructorUsedError;
}
